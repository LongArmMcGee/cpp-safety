= Safe C++
:revealjsdir: https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.9.2
:revealjs_theme: white
:revealjs_slideNumber: true
:revealjs_history: true
// :revealjs_showNotes: true
:icons: font
:source-highlighter: highlightjs

// [.reveal]
// [.columns]

// SHOW don't TELL, pictures of what is being said
// https://www.researchgate.net/publication/228516602_Eliminating_Buffer_Overflows_Using_the_Compiler_or_a_Standalone_Tool

== Topics

* Memory Safety is hot
* {cpp} has a bad rep
* All is not lost, there are solutions
* Core guidlines and GSL


== Memory Safety is Hot

image::images/MemSafePressReleases.jpg[]
// * The White House Office of the National Cyber Director (ONCD) link:https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/[press release] offering new guidance document that provides recommendations for securing cyber infrastructure. 
// *  The National Security Agency (NSA) has link:https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/[released] a new guidance document that provides recommendations for securing {cpp} code.
// // * A NIST link:https://www.nsa.gov/Press-Room/News-Highlights/Article/Article/3215760/nsa-releases-guidance-on-how-to-protect-against-software-memory-safety-issues/[press release] published guidance today to help software developers and operators prevent and mitigate software memory safety issues, which account for a large portion of exploitable vulnerabilities.
// * link:https://www.cisa.gov/case-memory-safe-roadmaps[CISA, NSA, FBI press release] pushing for meory safe roadmaps from organizations. 
// * and more...
// * Most of us have heard the "70% of all vulnerabilities are memory safety issues" statistic

== {cpp} has a bad reputation
// [quote, White House ONCD, A Path Toward Secure And Measurable Software, 2024-02-26]
[quote, White House ONCD]
"*memory unsafe* programming languages, such as *C and {cpp}*",

// _White House ONCD, A Path Toward Secure And Measurable Software, 2024-02-26_

// [quote, NSA, Cybersecurity Information Sheet, 2023-04]
[quote, NSA]
"NSA advises organizations to [...] shift from [...] *C/{cpp}* [...] to a memory safe language when possible"

// _NSA, Cybersecurity Information Sheet, 2023-04_

// [quote, CISA, The Case for Memory Safe Roadmaps, 2023-12]
[quote, CISA]
"C and {cpp} [...] can lead to memory unsafe code and are still among the most widely used languages today."

// _CISA, The Case for Memory Safe Roadmaps, 2023-12_

== Why is {cpp} unsafe?

* Type Safety
* Bounds Safety
* Lifetime Safety

=== Type Safety, Casting

[source, c++]
----
// IEEE 754 represnation of NaN
uint32_t NaN = 0x7F800001;
float f = *reinterpret_cast<float*>(&bad_value);

// May not be intended and may raise an exception
std::cout << f << std::endl;
----

=== Type Safety, Uninitialized Data

[source, c++]
----
float f1;
float f2;

// Uninitialized stack data can have arbitrary values 
// and result in a floating point exception
float f3 = f1 / f2;
----

=== Type Safety, Unions
[source, c++]
----
// We do this a lot with bits on HW systems
union Data
{
  uint32_t i;
  float f;
}

Data data;
data.i =  0x7F800001;

// NaN
std::cout << f;
----

// === Type Safety, varags
// TODO I don't know anything about varags
// Don't use va_arg


=== Bounds Safety, Raw arrays
// Bounds.1: Don’t use pointer arithmetic. Use span instead: Pass pointers to single objects (only) and Keep pointer arithmetic simple.
// Bounds.2: Only index into arrays using constant expressions: Pass pointers to single objects (only) and Keep pointer arithmetic simple.
// Bounds.3: No array-to-pointer decay: Pass pointers to single objects (only) and Keep pointer arithmetic simple.
// Bounds.4: Don’t use standard-library functions and types that are not bounds-checked: Use the standard library in a type-safe manner.

[source, c++]
----
// Raw arrays/pointers
char buffer[SIZE];

for(int i = 0; i=SIZE; i++){
  read(buffer[i]);  // WRONG: i = SIZE is out of bounds
}
----

=== Lifetime Safety, Use after free
[source, c++]
----
// lack of ownership/lifetime checking, 
int32_t* anInt = new int32_t(42);
delete anInt;
int32_t badRead = *anInt;
----



== Make C++ Safe

Replace unsafe features with safe alternatives.

The Guidelines Support Library (GSL) can provide these for older {cpp} standards versions

=== Avoid casting

Especially avoid C-style casts

[source, c++]
----
(uint16_t) long_data; // C-style cast
uint16_t (long_data); // C-style cast
static_cast<uint16_t>(long_data); // C++ style cast
const_cast<uint16_t>(long_data); // C++ style cast
reinterpret_cast<uint16_t>(long_data); // C++ style cast
----

=== Variants over Unions

[source, c++]
----
// Variants
std::variant<int, float> data;
data = 42;
int value = std::get<int>(data);
----

=== Ownership & Lifetimes

This is a lot to cover.
See clang-tidy ownership checker
// https://llvm.org/devmtg/2019-04/slides/TechTalk-Horvath-Implementing_the_C++_Core_Guidelines_Lifetime.pdf
https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines/owning-memory.html

=== Span over raw arrays
[source, c++]
----
    int array[] = {1, 2, 3, 4, 5};
    gsl::span<int, 5> s(array);

    for(int i : s) {
        std::cout << i << std::endl;
    }
----

=== Core Materials

image::images/CppCoreGuidelinesGSL.jpg[]

=== Foundational Docs of Safe C++

* Bjarne and Herb lay the groundwork in their white papers and talks
* See their _very_ detailed documents @ link:https://github.com/isocpp/CppCoreGuidelines/tree/master/docs[github.com/isocpp/CppCoreGuidelines/docs]
** link:https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf[A brief introduction to {cpp}'s model for type and resource safety]
** link:https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf[Lifetime Safety: Preventing ommon dangling]
// ** link:https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/P0122R4.pdf[span: bounds-safe views for sequences of objets]
// ** link:https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/ctor-dtor-raii-popl12.pdf[A Mehanized Semanticsc for {cpp} Objet Construction and Destruction, with Appliations to Resourcce Management]
// ** link:https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/gsl-intro.md[Using the Guidelines Support Library (GSL): A Tutorial and FAQ]
* They also have many talks available on youtube

== Adopting Safe C++

What's adoption look like?

* Use smart pointers over raw pointers (ownership built-in)
* Use span over raw arrays
* Use variants over unions
* Avoid type conversion, and use C++ style casts when necessary

=== Easy way

clang-tidy provides cppcoreguidelines-* checks to enforce these rules

image::images/CppStandards.jpg[]

== Safe C++ Static Analysis

* clang-tidy provides cppcoreguidelines-* checks to enforce these rules
* MISRA C++ 2023 also incorporates these rules and static analysis tools like LDRA and Polyspace can will enforce these rules once they support the new standard

[.columns]
== Column Text Alignment

[.column.has-text-left]
--
Something Short

Something So Long That We Need It Aligned
--

[.column.has-text-justified]
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

[.column.has-text-right]
--
Something Short

Something So Long That We Need It Aligned
--

[%auto-animate]
== !

[source%linenums,js,data-id=planets]
----
let planets = [
  { name: 'mars', diameter: 6779 },
]
----

[%auto-animate]
== !

[source%linenums,js,data-id=planets]
----
let planets = [
  { name: 'mars', diameter: 6779 },
  { name: 'earth', diameter: 12742 },
  { name: 'jupiter', diameter: 139820 }
]
----

[%auto-animate]
== !

[source%linenums,js,data-id=planets]
----
let circumferenceReducer = ( c, planet ) => {
  return c + planet.diameter * Math.PI;
}

let planets = [
  { name: 'mars', diameter: 6779 },
  { name: 'earth', diameter: 12742 },
  { name: 'jupiter', diameter: 139820 }
]

let c = planets.reduce( circumferenceReducer, 0 )
----